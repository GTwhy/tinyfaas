# Worker架构概述

在开发者将函数的二进制文件及其配置提交后，框架根据配置文件解析包含函数的二进制文件。在开发者提交的函数计算任务准备就绪后，框架开始监听与函数相关联的路由，等待用户请求。
负责处理用户请求，执行与请求对应函数的系统暂且称为运行时系统（Runtime）。运行时系统主要由三类实体组成，分别是Brick、Cart和Labor，对应关系如图。
![Worker架构图](../../image/Worker_architecture.png)
- Brick：函数计算任务的载体，框架调度、并发的基本单位。框架在接收到用户发送的请求即新建一个与之对应的brick，其中包含需要执行的函数指针、参数指针、运行状态、堆栈信息等。
- Cart：承载Brick队列及其运行所需资源的实体。其中包含多个Brick实体的任务队列、共享堆栈缓冲区和用于任务调度的各种参数。
- Labor：用于执行函数代码的实体。其本质是操作系统的线程，由操作系统负责调度。一个Labor对应一个Cart，并执行Cart中的Bricks。实体数量上L:C=M:N，一般N为CPU核心数，且M>N。框架将依据策略管理Labor与Cart的对应关系。例如Labor被操作系统阻塞时，Cart会对应其他Labor。

## 概念描述
### 搬砖的故事
通过这三个概念的命名，可以想象如下画面：
用户打电话（发请求）给砖厂要买砖(brick）。厂长（框架、调度器）于是指挥工人（labor）推一辆推车（carrt），根据订单（请求信息）从砖窑里搬砖给用户。有的砖刚烧制完成，很烫手，工人搬一块就要歇一下（阻塞）；也有时妈妈打电话喊他回家吃饭（被OS调度让出）。但是推车不怕烫，也没有妈，于是精明的厂长会安排多个工人轮流使用推车搬砖。
### 正经点
当用户请求了函数服务，框架在接到消息后新建一个Brick（或复用一个已经释放的Brick），将与请求相关信息如函数指针、参数等信息存入Brick。随后将该Brick指针插入到某Cart队列中，等待执行。
Cart任务队列中的任务不断被调度器弹出至与Cart对应的Labor，执行函数代码。
由于开发者提交的函数中可能包含某些系统调用导致Labor被操作系统长时间阻塞，或函数执行遇到问题导致超时。因此调度器会依据策略将Cart移交给其他空闲Labor，由新对应的Labor继续执行队列中的Brick。这也是一般情况下Cart数量与机器核心数相同且大于Labor数量的原因。
当被阻塞线程满足唤醒条件得以继续执行时，继续执行刚才的Brick。执行完毕后通过检查标志位发现自己已经没有对应的Cart，则休眠等待被调度器唤醒。
这样的设计主要是为了满足高并发场景下高性能、低资源占用的需求，同时保障框架的拓展性和多语言兼容性。
## 主要优势
1. 低资源占用。由于函数实体和运行时复用、堆栈共享，因此每个新增的并发只会增加KB级的内存消耗。
2. 低启动延迟。相较传统sls框架减少了任务无关代码耗时，且框架以极低占用保活，避免了容器冷启动导致的高延迟。
3. 高执行速度。将调度单位与资源单位解耦，充分利用了多核、缓存等硬件特性提高了代码的执行速度和效率。无锁多队列设计避免了数据竞争可能导致的延迟和死锁。
4. 多语言支持。虽然该框架以支持二进制任务实体为初级目标，但也考虑到了后续对多语言支持。在BCL架构中，B、C是语言无关的，只记录了必要的参数，而Labor则可以适配多语言，可以有Binary-Labor，也可以有Python-Labor。

